'use strict';

const util = require('util');
const Environment = require('./nunjucks-no-chokidar').Environment;
const Require = require('./tag-require');
const Resource = require('./resource');
const utils = require('./utils/');
const extend = require('extend');

const DEFAULT_RESOURCE_OPTIONS = {
  autoescape: true,
  logger: console,
  resource: {
    combine: false,
    cache: false,
    resolve: function(resourceList, type) {
      let regexp, ext;
      if (type === 'javascript') {
        regexp = utils.RE_SCRIPT;
        ext = '.js';
      } else if (type === 'stylesheet') {
        regexp = utils.RE_STYLE;
        ext = '.css';
      } else {
        return '';
      }

      return resourceList.map(function(file) {
        return file.replace(regexp, '');
      }).join(',') + ext;
    },
    locals: function(locals) {
      return '<script>window.context=' + getString(locals) + ';</script>';
    },
    map: {},
  },
};

function resolve(filepath) {
  if (!filepath) { return ''; }

  switch (filepath[0]) {
    case '/':
      return filepath.substring(1);
    case '.':
      // TODO: 目前因为无法获得当前模板所在路径，所以无法解析出相对路径。
      // 将来可以解决相对路径时，亦应该注意不要访问到项目根目录之外。
      return '';
    default:
      return filepath;
  }
}

const escapeMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
};

function getString(locals) {
  const str = JSON.stringify(locals);
  if (!str) {
    return str;
  }
  return str.replace(/[&<>]/g, function(ch) {
    return escapeMap[ch];
  });
}

module.exports = SafeEnvironment;

function SafeEnvironment(loaders, opts) {
  // TODO: deep merge and multiple instance support.
  const resourceOptions = extend(true, {}, DEFAULT_RESOURCE_OPTIONS.resource, (opts || {}).resource);
  opts = this.options = extend(true, {}, DEFAULT_RESOURCE_OPTIONS, opts);
  opts.resource = resourceOptions;
  Environment.call(this, loaders, opts);

  this._logger = opts.logger;

  let requireOptions;
  if (opts.resource.combine) {
    requireOptions = {
      run: function(context, filepath) {
        this._resource.use(resolve(filepath));
      }.bind(this),
    };
  }

  if (opts.resource.cache) {
    // 根据模板名称（render）或模板内容（renderString）缓存使用的静态资源。
    this._resourceCache = {};
  }

  this._resource = new Resource(opts.resource);
  this.addExtension('RequireExtension', new Require(requireOptions));

}

util.inherits(SafeEnvironment, Environment);

const proto = SafeEnvironment.prototype;

/**
 * 将静态资源合并添加到模板头、尾。
 * @param {String} key, resource cache key name.
 * @param {String} html, inject target html source code.
 * @param {Resource} resource,
 * @param {Object} locals,
 * @return {void}
 */
proto._injectStatic = function(key, html, resource, locals) {
  // 支持通过 hostname 修改静态资源
  // http://gitlab.alipay-inc.com/chair/chair/issues/1743
  const hostname = locals && locals._subApp;
  if (hostname) {
    resource.addHost(hostname);
  }

  const enableCache = this.options.resource.cache;
  let jsKey;
  let cssKey;
  let js;
  let css;

  if (enableCache) {
    const jsKey = `${key}:${resource.getScriptKey()}`;
    const cssKey = `${key}:${resource.getStyleKey()}`;
    js = this._resourceCache[jsKey];
    css = this._resourceCache[cssKey];
  }

  if (!js) {
    js = resource.getScript();
    if (enableCache) this._resourceCache[jsKey] = js;
  }
  if (!css) {
    css = resource.getStyle();
    if (enableCache) this._resourceCache[cssKey] = css;
  }

  const headCloseIndex = html.indexOf('</head>');
  if (headCloseIndex >= 0) {
    html = html.substring(0, headCloseIndex) + css + html.substring(headCloseIndex);
  } else {
    html = css + html;
  }

  if (js) {
    // 添加页面上下文数据。
    js = this.options.resource.locals(locals) + js;
  }
  const bodyCloseIndex = html.indexOf('</body>');
  if (bodyCloseIndex >= 0) {
    html = html.substring(0, bodyCloseIndex) + js + html.substring(bodyCloseIndex);
  } else {
    html = html + js;
  }

  return html;
};

proto.render = function(name, locals, cb) {
  this._resource.reset();
  this._resource.bindRenderFile(name);

  let syncResult;
  Environment.prototype.render.call(this, name, locals, function(err, res) {
    if (err) {
      if (cb) {
        // 对于 async 调用, 需要使用 callback 回调
        return cb(err);
      } else {
        throw err;
      }
    }
    syncResult = res;

    if (this.options.resource.combine) {
      syncResult = this._injectStatic(name, syncResult, this._resource, locals);
    }

    if (cb) {
      cb(err, syncResult);
    }

  }.bind(this));

  return syncResult;

};

proto.renderString = function(src, locals, cb) {
  this._resource.reset();

  let syncResult;
  Environment.prototype.renderString.call(this, src, locals, function(err, res) {
    if (err) {
      if (cb) {
        // 对于 async 调用, 需要使用 callback 回调
        return cb(err);
      } else {
        throw err;
      }
    }
    syncResult = res;

    if (this.options.resource.combine) {
      syncResult = this._injectStatic(src, syncResult, this._resource, locals);
    }

    if (cb) {
      cb(err, syncResult);
    }
  }.bind(this));
  return syncResult;
};

proto.getFilter = function(name) {
  if (!this.filters[name]) {
    let err = new Error('nunjucks filter not found: ' + name);
    err.name = 'NunjucksFilterNotFound';
    if (process.env.NODE_ENV === 'production') {
      this.filters[name] = ignore;
      this._logger.error(err);
    } else {
      throw err;
    }
  }
  return this.filters[name];
};

// clean up all cache
proto.cleanCache = function() {
  let count = 0;
  for (let i = 0; i < this.loaders.length; i++) {
    const loader = this.loaders[i];
    for (let name in loader.cache) {
      if (loader.cache[name]) {
        count++;
        loader.cache[name] = null;
      }
    }
  }

  return count;
};

function ignore(val) {
  return val;
}
